/*! instant.page v5.2.0 - (C) 2019-2025 Alexandre Dieulot - https://instant.page/license */
let t,e,n,o,i,r,a=null,s=65,c=new Set;function u(t){i=t;const e=t.target.closest("a");g(e)&&v(e.href,"high")}function d(t){i=t}function l(t){if(h(t))
// This avoids uselessly adding a mouseout event listener and setting a timer.
return;if(!("closest"in t.target))return;
// Without this check sometimes an error “event.target.closest is not a function” is thrown, for unknown reasons
// That error denotes that `event.target` isn’t undefined. My best guess is that it’s the Document.
//
// Details could be gleaned from throwing such an error:
//throw new TypeError(`instant.page non-element event target: timeStamp=${~~event.timeStamp}, type=${event.type}, typeof=${typeof event.target}, nodeType=${event.target.nodeType}, nodeName=${event.target.nodeName}, viewport=${innerWidth}x${innerHeight}, coords=${event.clientX}x${event.clientY}, scroll=${scrollX}x${scrollY}`)
const e=t.target.closest("a");g(e)&&(e.addEventListener("mouseout",p,{passive:!0}),r=setTimeout(()=>{v(e.href,"high"),r=null},s))}function f(t){if(h(t))
// When preloading only on mousedown, not touch, we need to stop there
// because touches send compatibility mouse events including mousedown.
//
// (When preloading on touchstart, instructions below this block would
// have no effect.)
return;const e=t.target.closest("a");g(e)&&v(e.href,"high")}function p(t){t.relatedTarget&&t.target.closest("a")==t.relatedTarget.closest("a")||r&&(clearTimeout(r),r=null)}function m(t){if(h(t))
// Due to a high potential for complications with this mousedown shortcut
// combined with other parties’ JavaScript code, we don’t want it to run
// at all on touch devices, even though mousedown and click are triggered
// at almost the same time on touch.
return;const e=t.target.closest("a");if(t.which>1||t.metaKey||t.ctrlKey)return;if(!e)return;e.addEventListener("click",function(t){1337!=t.detail&&t.preventDefault()},{capture:!0,passive:!1,once:!0});const n=new MouseEvent("click",{view:window,bubbles:!0,cancelable:!1,detail:1337});e.dispatchEvent(n)}function h(t){
// Touch devices fire “mouseover” and “mousedown” (and other) events after
// a touch for compatibility reasons.
// This function checks if it’s likely that we’re dealing with such an event.
if(!i||!t)return!1;if(t.target!=i.target)return!1;
// How long after a touchstart event can a simulated mouseover/mousedown event fire?
// /test/extras/delay-not-considered-touch.html tries to answer that question.
// I saw up to 1450 ms on an overwhelmed Samsung Galaxy S2.
// On the other hand, how soon can an unrelated mouseover event happen after an unrelated touchstart?
// Meaning the user taps a link, then grabs their pointing device and clicks another/the same link.
// That scenario could occur if a user taps a link, thinks it hasn’t worked, and thus fall back to their pointing device.
// I do that in about 1200 ms on a Chromebook. In which case this function returns a false positive.
// False positives are okay, as this function is only used to decide to abort handling mouseover/mousedown/mousedownShortcut.
// False negatives could lead to unforeseen state, particularly in mousedownShortcutListener.
return t.timeStamp-i.timeStamp<2500;
// TODO: Investigate if pointer events could be used.
// https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/pointerType
// TODO: Investigate if InputDeviceCapabilities could be used to make it
// less hacky on Chromium browsers.
// https://developer.mozilla.org/en-US/docs/Web/API/InputDeviceCapabilities_API
// https://wicg.github.io/input-device-capabilities/
// Needs careful reading of the spec and tests (notably, what happens with a
// mouse connected to an Android or iOS smartphone?) to make sure it’s solid.
// Also need to judge if WebKit could implement it differently, as they
// don’t mind doing when a spec gives room to interpretation.
// It seems to work well on Chrome on ChromeOS.
// TODO: Consider using event screen position as another heuristic.
}function g(t){if(t&&t.href&&(!o||"instant"in t.dataset)){if(t.origin!=location.origin){if(!(n||"instant"in t.dataset)||!a)
// Chromium-only: see comment on “restrictive prefetch” and “cross-site speculation rules prefetch”
return}if(["http:","https:"].includes(t.protocol)&&("http:"!=t.protocol||"https:"!=location.protocol)&&(e||!t.search||"instant"in t.dataset)&&!(t.hash&&t.pathname+t.search==location.pathname+location.search||"noInstant"in t.dataset))return!0}}function v(e,n="auto"){c.has(e)||("none"!=t?function(e){const n=document.createElement("script");n.type="speculationrules",n.textContent=JSON.stringify({[t]:[{source:"list",urls:[e]}]}),
// When using speculation rules, cross-site prefetch is supported, but will
// only work if the user has no cookies for the destination site. The
// prefetch will not be sent, if the user does have such cookies.
document.head.appendChild(n)}(e):function(t,e="auto"){const n=document.createElement("link");n.rel="prefetch",n.href=t,n.fetchPriority=e,
// By default, a prefetch is loaded with a low priority.
// When there’s a fair chance that this prefetch is going to be used in the
// near term (= after a touch/mouse event), giving it a high priority helps
// make the page load faster in case there are other resources loading.
// Prioritizing it implicitly means deprioritizing every other resource
// that’s loading on the page. Due to HTML documents usually being much
// smaller than other resources (notably images and JavaScript), and
// prefetches happening once the initial page is sufficiently loaded,
// this theft of bandwidth should rarely be detrimental.
n.as="document",
// as=document is Chromium-only and allows cross-origin prefetches to be
// usable for navigation. They call it “restrictive prefetch” and intend
// to remove it: https://crbug.com/1352371
//
// This document from the Chrome team dated 2022-08-10
// https://docs.google.com/document/d/1x232KJUIwIf-k08vpNfV85sVCRHkAxldfuIA5KOqi6M
// claims (I haven’t tested) that data- and battery-saver modes as well as
// the setting to disable preloading do not disable restrictive prefetch,
// unlike regular prefetch. That’s good for prefetching on a touch/mouse
// event, but might be bad when prefetching every link in the viewport.
document.head.appendChild(n)}(e,n),c.add(e))}!function(){const i=document.createElement("link").relList;if(!i.supports("prefetch"))return;const r="throwIfAborted"in AbortSignal.prototype,c=i.supports("modulepreload"),p=Intl.PluralRules&&"selectRange"in Intl.PluralRules.prototype;// Chromium 100+, Safari 15.4+, Firefox 97+
if(!r||!c&&!p)return;
// In order to lessen maintenance and unnoticed bugs we only support:
// - Chromium ⩾ 100 — UC Browser 14
// - Gecko as in Firefox ⩾ 115 — last version supported on Windows 7
// - WebKit as in Safari ⩾ 15.4 — last major WebKit version supported on iPhone 6s & 7
//
// WebKit doesn’t support prefetch anyway, but instant.page might
// eventually drop this requirement by providing an option for
// fetch()-based preloading.
//
// Additionally, instant.page should not cause JavaScript errors in:
// - Chromium ⩾ 61
// - Gecko as in Firefox ⩾ 60
// - WebKit as in Safari ⩾ 10.1 (iOS ⩾ 10.3 and macOS ⩾ 10.10)
// Browser engines older than that don’t support <script type=module>
// and thus don’t load instant.page at all.
const h="instantVaryAccept"in document.body.dataset||"Shopify"in window,y=navigator.userAgent.indexOf("Chrome/");
// The `Vary: Accept` header when received in Chromium 79–109 makes prefetches
// unusable, as Chromium used to send a different `Accept` header.
// It’s applied on all Shopify sites by default, as Shopify is very popular
// and is the main source of this problem.
// `window.Shopify` only exists on “classic” Shopify sites. Those using
// Hydrogen (Remix SPA) aren’t concerned.
y>-1&&(a=parseInt(navigator.userAgent.substring(y+"Chrome/".length)));
// The user agent client hints API is a theoretically more reliable way to
// get Chromium’s version… but it’s not available in Samsung Internet 20.
// It also requires a secure context, which would make debugging harder,
// and is only available in recent Chromium versions.
// In practice, Chromium browsers never shy from announcing "Chrome" in
// their regular user agent string, as that maximizes their compatibility.
if(h&&a&&a<110)return;if(t="none",HTMLScriptElement.supports&&HTMLScriptElement.supports("speculationrules")){const e=document.body.dataset.instantSpecrules;"prerender"==e?t="prerender":"no"!=e&&(t="prefetch")}const w="instantMousedownShortcut"in document.body.dataset;e="instantAllowQueryString"in document.body.dataset,n="instantAllowExternalLinks"in document.body.dataset,o="instantWhitelist"in document.body.dataset;let b=!1,E=!1,S=!1;if("instantIntensity"in document.body.dataset){const t=document.body.dataset.instantIntensity;if("mousedown"!=t||w||(b=!0),"mousedown-only"!=t||w||(b=!0,E=!0),"viewport"==t){const t=document.documentElement.clientWidth*document.documentElement.clientHeight<45e4,e=navigator.connection&&navigator.connection.saveData,n=navigator.connection&&navigator.connection.effectiveType&&navigator.connection.effectiveType.includes("2g"),o=!e&&!n;
// Smartphones are the most likely to have a slow connection, and
// their small screen size limits the number of links (and thus
// server load).
//
// Foldable phones (being expensive as of 2023), tablets and PCs
// generally have a decent connection, and a big screen displaying
// more links that would put more load on the server.
//
// iPhone 14 Pro Max (want): 430×932 = 400 760
// Samsung Galaxy S22 Ultra with display size set to 80% (want):
// 450×965 = 434 250
// Small tablet (don’t want): 600×960 = 576 000
// Those number are virtual screen size, the viewport (used for
// the check above) will be smaller with the browser’s interface.
t&&o&&(S=!0)}"viewport-all"==t&&(S=!0);const e=parseInt(t);isNaN(e)||(s=e)}const I={capture:!0,passive:!0};E?document.addEventListener("touchstart",d,I):document.addEventListener("touchstart",u,I);b||document.addEventListener("mouseover",l,I);b&&document.addEventListener("mousedown",f,I);w&&document.addEventListener("mousedown",m,I);if(S){let t=window.requestIdleCallback;
// Safari has no support as of 16.3: https://webkit.org/b/164193
t||(t=(t=>{t();
// A smarter fallback like setTimeout is not used because devices that
// may eventually be eligible to a Safari version supporting prefetch
// will be very powerful.
// The weakest devices that could be eligible are the 2017 iPad and
// the 2016 MacBook.
})),t(function(){const t=new IntersectionObserver(e=>{e.forEach(e=>{if(e.isIntersecting){const n=e.target;t.unobserve(n),v(n.href)}})});document.querySelectorAll("a").forEach(e=>{g(e)&&t.observe(e)})},{timeout:1500})}}();